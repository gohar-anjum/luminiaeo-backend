<?php

namespace App\Services;

use App\DTOs\CitationRequestDTO;
use App\Interfaces\CitationRepositoryInterface;
use App\Jobs\CitationChunkJob;
use App\Jobs\ProcessCitationTaskJob;
use App\Models\CitationTask;
use App\Services\LLM\LLMClient;
use App\Services\DataForSEO\CitationService as DataForSEOCitationService;
use Illuminate\Support\Facades\Log;

class CitationService
{
    public function __construct(
        protected CitationRepositoryInterface $repository,
        protected LLMClient $llmClient,
        protected ?DataForSEOCitationService $dataForSEOCitationService = null
    ) {
        if (config('citations.dataforseo.enabled', false)) {
            try {
                $this->dataForSEOCitationService = app(DataForSEOCitationService::class);
            } catch (\Exception $e) {
                Log::warning('DataForSEO Citation Service not available', ['error' => $e->getMessage()]);
            }
        }
    }

    public function createTask(CitationRequestDTO $dto): CitationTask
    {
        $cacheDays = config('citations.cache_days', 30);
        $existingTask = $this->repository->findCompletedByUrl($dto->url, $cacheDays);

        if ($existingTask) {
            Log::info('Returning cached citation task', [
                'task_id' => $existingTask->id,
                'url' => $dto->url,
                'cached_at' => $existingTask->created_at,
            ]);
            return $existingTask;
        }

        $max = config('citations.max_queries');
        $numQueries = min(max($dto->numQueries, 1), $max);

        $normalizedUrl = $this->normalizeUrl($dto->url);
        $task = $this->repository->create([
            'url' => $normalizedUrl,
            'status' => CitationTask::STATUS_GENERATING,
            'meta' => [
                'requested_queries' => $dto->numQueries,
                'num_queries' => $numQueries,
            ],
        ]);

        $queries = $this->generateQueries($normalizedUrl, $numQueries);

        if (empty($queries)) {
            Log::warning('No queries generated by AI for citation task', [
                'task_id' => $task->id,
                'url' => $normalizedUrl,
            ]);
            $this->repository->update($task, [
                'status' => CitationTask::STATUS_FAILED,
                'meta' => array_merge($task->meta ?? [], [
                    'error' => 'No queries generated by AI',
                ]),
            ]);
            return $task->fresh();
        }

        $this->repository->update($task, [
            'queries' => $queries,
            'status' => CitationTask::STATUS_QUEUED,
        ]);

        ProcessCitationTaskJob::dispatch($task->id);

        return $task->fresh();
    }

    protected function normalizeUrl(string $url): string
    {
        $url = trim($url);

        if (!preg_match('/^https?:\/\//', $url)) {
            $url = 'https://' . $url;
        }

        $parsed = parse_url($url);
        if (!$parsed) {
            return $url;
        }

        $scheme = $parsed['scheme'] ?? 'https';
        $host = strtolower($parsed['host'] ?? '');
        $host = preg_replace('/^www\./', '', $host);
        $path = rtrim($parsed['path'] ?? '', '/');
        $query = $parsed['query'] ?? '';
        $fragment = $parsed['fragment'] ?? '';

        $normalized = $scheme . '://' . $host . $path;
        if ($query) {
            $normalized .= '?' . $query;
        }
        if ($fragment) {
            $normalized .= '#' . $fragment;
        }

        return $normalized;
    }

    public function generateQueries(string $url, int $numQueries): array
    {
        $llmQueries = $this->llmClient->generateQueries($url, $numQueries);
        $queries = collect($llmQueries);

        return $queries
            ->map(fn ($q) => $this->sanitizeQuery($q))
            ->filter()
            ->unique()
            ->take($numQueries)
            ->values()
            ->all();
    }

    public function dispatchChunkJobs(CitationTask $task): void
    {
        $queries = $task->queries ?? [];
        $chunkSize = max(1, config('citations.chunk_size', 10));
        $chunks = array_chunk($queries, $chunkSize, true);
        $delay = config('citations.chunk_delay_seconds', 0);

        foreach ($chunks as $offset => $chunk) {
            $job = new CitationChunkJob($task->id, $chunk, $offset * $chunkSize, count($queries));
            if ($delay > 0) {
                dispatch($job)->delay(now()->addSeconds($delay * $offset));
            } else {
                dispatch($job);
            }
        }
    }

    public function dispatchPartialChunks(CitationTask $task, array $subset): void
    {
        if (empty($subset)) {
            return;
        }

        if ($task->status !== CitationTask::STATUS_PROCESSING) {
            $this->repository->update($task, ['status' => CitationTask::STATUS_PROCESSING]);
        }

        $chunkSize = max(1, config('citations.chunk_size', 10));
        $chunks = array_chunk($subset, $chunkSize, true);

        foreach ($chunks as $chunk) {
            dispatch(new CitationChunkJob($task->id, $chunk, 0, count($task->queries ?? [])));
        }
    }

    public function mergeChunkResults(CitationTask $task, array $results, array $meta = [], array $progress = []): CitationTask
    {
        $progress['total'] = $progress['total'] ?? count($task->queries ?? []);

        return $this->repository->appendResults($task, [
            'by_query' => $results,
            'meta' => $meta,
            'progress' => $progress,
        ]);
    }

    public function finalizeTask(CitationTask $task): CitationTask
    {
        $results = $task->results['by_query'] ?? [];
        $stats = $this->calculateScores($results);
        $competitors = $this->computeCompetitors($results, $task->url);

        $meta = [
            'gpt_score' => $stats['gpt_score'],
            'gemini_score' => $stats['gemini_score'],
            'status' => CitationTask::STATUS_COMPLETED,
            'completed_at' => now()->toIso8601String(),
        ];

        // Add DataForSEO score if available
        if (isset($stats['dataforseo_score'])) {
            $meta['dataforseo_score'] = $stats['dataforseo_score'];
        }

        return $this->repository->updateCompetitorsAndMeta(
            $task,
            $competitors,
            $meta
        );
    }

    public function recordFailure(CitationTask $task, string $message): CitationTask
    {
        Log::error('Citation task failed', [
            'task_id' => $task->id,
            'error' => $message,
        ]);

        $meta = $task->meta ?? [];
        $errors = $meta['errors'] ?? [];
        $errors[] = [
            'message' => $message,
            'timestamp' => now()->toIso8601String(),
        ];
        $meta['errors'] = $errors;

        return $this->repository->update($task, [
            'status' => CitationTask::STATUS_FAILED,
            'meta' => $meta,
        ]);
    }

    public function computeCompetitors(array $byQuery, string $targetUrl): array
    {
        $targetDomainNormalized = $this->normalizeDomainForGrouping($targetUrl);
        $targetDomainVariations = $this->getDomainVariations($targetUrl);

        Log::debug('Computing competitors', [
            'target_url' => $targetUrl,
            'target_normalized' => $targetDomainNormalized,
            'target_variations' => $targetDomainVariations,
        ]);

        $competitorData = [];
        $totalQueries = count($byQuery);
        $totalCitations = 0;

        foreach ($byQuery as $entry) {
            $query = $entry['query'] ?? '';
            $queryCompetitors = $entry['top_competitors'] ?? [];
            $queryHasCitation = false;

            // Check for citations from any provider (gpt, gemini, or dataforseo)
            foreach (['gpt', 'gemini'] as $provider) {
                if (!empty($entry[$provider]['citation_found'])) {
                    $queryHasCitation = true;
                }
                // Also check if gpt field contains dataforseo provider
                if ($provider === 'gpt' && isset($entry['gpt']['provider']) && $entry['gpt']['provider'] === 'dataforseo') {
                    if (!empty($entry['gpt']['citation_found'])) {
                        $queryHasCitation = true;
                    }
                }
            }

            if ($queryHasCitation) {
                $totalCitations++;
            }

            foreach ($queryCompetitors as $competitor) {
                $domain = $this->normalizeDomainForGrouping($competitor['domain'] ?? '');
                if (!$domain || $this->isTargetDomain($domain, $targetDomainVariations)) {
                    continue;
                }

                if (!isset($competitorData[$domain])) {
                    $competitorData[$domain] = [
                        'domain' => $domain,
                        'citation_count' => 0,
                        'query_count' => 0,
                        'queries' => [],
                        'urls' => [],
                        'providers' => ['gpt' => 0, 'gemini' => 0],
                    ];
                }

                $competitorData[$domain]['citation_count'] += $competitor['mentions'] ?? 1;

                if (!in_array($query, $competitorData[$domain]['queries'], true)) {
                    $competitorData[$domain]['query_count']++;
                    $competitorData[$domain]['queries'][] = $query;
                }

                foreach ($competitor['urls'] ?? [] as $url) {
                    if (!in_array($url, $competitorData[$domain]['urls'], true)) {
                        $competitorData[$domain]['urls'][] = $url;
                    }
                }

                foreach (['gpt', 'gemini'] as $provider) {
                    $providerCompetitors = $entry[$provider]['competitors'] ?? [];
                    // Also check if gpt contains dataforseo results
                    if ($provider === 'gpt' && isset($entry['gpt']['provider']) && $entry['gpt']['provider'] === 'dataforseo') {
                        $providerCompetitors = array_merge($providerCompetitors, $entry['gpt']['competitors'] ?? []);
                    }
                    foreach ($providerCompetitors as $providerCompetitor) {
                        $providerDomain = $this->normalizeDomainForGrouping($providerCompetitor['domain'] ?? ($providerCompetitor['url'] ?? ''));
                        if ($providerDomain && $providerDomain === $domain) {
                            $competitorData[$domain]['providers'][$provider]++;
                            break;
                        }
                    }
                }
            }
        }

        $totalCompetitorMentions = array_sum(array_column($competitorData, 'citation_count'));

        foreach ($competitorData as &$competitor) {
            $competitor['percentage'] = $totalCompetitorMentions > 0
                ? round(($competitor['citation_count'] / $totalCompetitorMentions) * 100, 2)
                : 0;
            $competitor['query_percentage'] = $totalQueries > 0
                ? round(($competitor['query_count'] / $totalQueries) * 100, 2)
                : 0;

            $competitor['urls'] = array_slice($competitor['urls'], 0, 10);
            $competitor['queries'] = array_slice($competitor['queries'], 0, 10);
        }
        unset($competitor);

        usort($competitorData, fn($a, $b) => $b['citation_count'] <=> $a['citation_count']);
        $topCompetitors = array_slice($competitorData, 0, 20);

        return [
            'total_citations' => $totalCitations,
            'total_queries' => $totalQueries,
            'competitors' => $topCompetitors,
        ];
    }

    protected function extractDomain(string $url): ?string
    {
        $domain = parse_url($url, PHP_URL_HOST);
        if (!$domain) {
            return null;
        }

        $domain = strtolower($domain);
        $domain = preg_replace('/^www\./', '', $domain);

        return $domain;
    }

    protected function normalizeDomainForGrouping(string $domain): string
    {
        if (empty($domain)) {
            return $domain;
        }

        $normalized = strtolower(trim($domain));

        if (preg_match('/^https?:\/\//', $normalized)) {
            $normalized = parse_url($normalized, PHP_URL_HOST) ?: $normalized;
        }

        $normalized = preg_replace('/^www\./', '', $normalized);

        $parts = explode('.', $normalized);
        if (count($parts) >= 2) {
            $baseDomain = $parts[count($parts) - 2] . '.' . $parts[count($parts) - 1];
            return $baseDomain;
        }

        return $normalized;
    }

    protected function getDomainVariations(string $domainOrUrl): array
    {
        $normalized = $this->normalizeDomainForGrouping($domainOrUrl);
        if (!$normalized) {
            return [];
        }

        $variations = [$normalized];

        if (strpos($normalized, 'cricinfo') !== false) {
            $variations[] = 'cricinfo.com';
            $variations[] = 'espncricinfo.com';
        }

        return array_unique(array_filter($variations));
    }

    protected function isTargetDomain(string $normalizedDomain, array $targetVariations): bool
    {
        if (empty($normalizedDomain)) {
            return false;
        }

        foreach ($targetVariations as $variation) {
            $normalizedVariation = $this->normalizeDomainForGrouping($variation);
            if ($normalizedDomain === $normalizedVariation && !empty($normalizedVariation)) {
                return true;
            }
        }
        return false;
    }

    protected function calculateScores(array $results): array
    {
        $total = max(count($results), 1);
        $gptHits = 0;
        $geminiHits = 0;
        $dataforseoHits = 0;

        foreach ($results as $entry) {
            if (!empty($entry['gpt']['citation_found'])) {
                $gptHits++;
            }
            if (!empty($entry['gemini']['citation_found'])) {
                $geminiHits++;
            }
            // Check for DataForSEO results
            if (!empty($entry['gpt']['provider']) && $entry['gpt']['provider'] === 'dataforseo') {
                if (!empty($entry['gpt']['citation_found'])) {
                    $dataforseoHits++;
                }
            }
        }

        // If DataForSEO is enabled, use DataForSEO score
        if (config('citations.dataforseo.enabled', false) && $dataforseoHits > 0) {
            return [
                'gpt_score' => round(($dataforseoHits / $total) * 100, 2),
                'gemini_score' => 0.0,
                'dataforseo_score' => round(($dataforseoHits / $total) * 100, 2),
            ];
        }

        return [
            'gpt_score' => round(($gptHits / $total) * 100, 2),
            'gemini_score' => round(($geminiHits / $total) * 100, 2),
        ];
    }

    protected function buildTemplateQueries(string $url, int $desiredCount): array
    {
        $host = parse_url($url, PHP_URL_HOST) ?: $url;
        $brand = $this->extractBrand($host);
        $keywords = $this->deriveAudienceKeywords($url) ?: [$brand];
        $themes = [
            'solutions',
            'success stories',
            'pricing',
            'setup',
            'tutorial',
            'best practices',
            'customer reviews',
            'benefits',
            'use cases',
            'faq',
            'case study',
            'benchmark',
            'community',
            'webinar',
            'playbook',
        ];

        $queries = [];
        foreach ($keywords as $keyword) {
            $queries[] = trim("{$brand} {$keyword} overview");
            $queries[] = trim("{$keyword} by {$brand}");
            foreach ($themes as $theme) {
                $queries[] = trim("{$brand} {$keyword} {$theme}");
            }
            $queries[] = trim("{$brand} for {$keyword}");
            $queries[] = trim("{$keyword} powered by {$brand}");
        }

        return array_slice(array_values(array_unique($queries)), 0, max($desiredCount, 30));
    }

    protected function generateGenericQueries(string $url, int $count): array
    {
        $keywords = $this->deriveAudienceKeywords($url);
        if (empty($keywords)) {
            $generic = [
                'How to get started?',
                'What are best practices?',
                'How to optimize performance?',
                'What are common challenges?',
                'How to implement solutions?',
            ];
            return array_slice($generic, 0, $count);
        }

        $questionStarters = [
            'How to',
            'What are',
            'Why is',
            'When should',
            'Where can',
        ];

        $actionWords = [
            'optimize',
            'implement',
            'improve',
            'manage',
            'scale',
        ];

        $fallbacks = [];
        for ($i = 0; $i < $count; $i++) {
            $keyword = $keywords[$i % count($keywords)];
            $starter = $questionStarters[$i % count($questionStarters)];
            $action = $actionWords[$i % count($actionWords)];

            if ($starter === 'How to') {
                $fallbacks[] = trim("{$starter} {$action} {$keyword}?");
            } else {
                $fallbacks[] = trim("{$starter} {$keyword} {$action}?");
            }
        }

        return $fallbacks;
    }

    protected function fallbackQueries(string $url, int $count): array
    {
        return $this->generateGenericQueries($url, $count);
    }

    protected function sanitizeQuery(string $query): ?string
    {
        $clean = trim(preg_replace('/[^a-zA-Z0-9\\s]/', ' ', $query));
        $clean = preg_replace('/\\s+/', ' ', $clean);

        if (empty($clean)) {
            return null;
        }

        return mb_substr($clean, 0, 60);
    }

    protected function extractBrand(string $host): string
    {
        $host = preg_replace('/^www\\./', '', $host);
        $parts = explode('.', $host);
        return $parts[0] ?? $host;
    }

    protected function deriveAudienceKeywords(string $url): array
    {
        $host = parse_url($url, PHP_URL_HOST) ?: $url;
        $host = strtolower(preg_replace('/^www\\./', '', $host));
        $stopWords = ['com', 'net', 'org', 'io', 'co', 'www', 'app', 'site'];
        $tokens = preg_split('/[\\.\\-]/', $host);
        $keywords = array_filter($tokens, function ($token) use ($stopWords) {
            return $token && !in_array($token, $stopWords, true) && strlen($token) > 2;
        });

        $path = parse_url($url, PHP_URL_PATH) ?? '';
        $pathTokens = array_filter(preg_split('/[\\/\\-_]/', trim($path, '/')));
        foreach ($pathTokens as $token) {
            $clean = trim(preg_replace('/[^a-zA-Z0-9 ]/', ' ', $token));
            if ($clean && strlen($clean) > 2) {
                $keywords[] = $clean;
            }
        }

        return array_values(array_unique(array_map(fn ($token) => str_replace('-', ' ', $token), $keywords)));
    }

}
